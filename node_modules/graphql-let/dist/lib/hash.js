"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readHash = exports.withHash = exports.createHashFromBuffers = exports.createHash = void 0;
const crypto_1 = __importDefault(require("crypto"));
const fs_1 = require("fs");
const os_1 = require("os");
const shouldCareNewline = os_1.EOL !== '\n';
const RegexCRLF = /\r\n/g;
const leadingLettersForFileHash = '/* ';
const hexHashLength = 40;
function normalizeNewline(input) {
    const str = Buffer.isBuffer(input) ? input.toString() : input;
    if (shouldCareNewline)
        return str.replace(RegexCRLF, '\n');
    return str;
}
function createHash(s) {
    return crypto_1.default.createHash('sha1').update(normalizeNewline(s)).digest('hex');
}
exports.createHash = createHash;
function createHashFromBuffers(ss) {
    const hash = crypto_1.default.createHash('sha1');
    for (const s of ss)
        hash.update(normalizeNewline(s));
    return hash.digest('hex');
}
exports.createHashFromBuffers = createHashFromBuffers;
function withHash(sourceHash, content) {
    return `${leadingLettersForFileHash}${sourceHash}
 * This file is automatically generated by graphql-let. */

${content}`;
}
exports.withHash = withHash;
function readHash(filePath) {
    try {
        // Sync is the fastest for a limited sized file to read hash
        // https://gist.github.com/piglovesyou/537a8157ba691e8e9e023263bfc7838d
        const content = fs_1.readFileSync(filePath, 'utf-8');
        const hash = content.slice(leadingLettersForFileHash.length, leadingLettersForFileHash.length + hexHashLength);
        if (hash)
            return hash;
        return null;
    }
    catch (error) {
        if (error.code === 'ENOENT')
            return null;
        throw error;
    }
}
exports.readHash = readHash;
